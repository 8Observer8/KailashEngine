
layout (local_size_x = 1024) in;


uniform sampler2D sampler0;				// Source Texture
writeonly uniform image2D sampler1;		// Destination Texture
uniform sampler2D sampler2;				// COC

shared vec3 cache[gl_WorkGroupSize.x * 2];


uniform int flip;
uniform vec2 texture_size;


void main() 
{
	uint id = gl_LocalInvocationID.x;

	ivec2 texCoord_1;
	ivec2 texCoord_2;
	int texCoord_index_1;
	int texCoord_index_2;
	float texture_size_early_out;

	if(flip == 0)
	{
		texCoord_1 = ivec2(id * 2, gl_WorkGroupID.x);
		texCoord_2 = ivec2(id * 2 + 1, gl_WorkGroupID.x);

		texCoord_index_1 = texCoord_1.x;
		texCoord_index_2 = texCoord_2.x;

		texture_size_early_out = texture_size.x;
	}
	else
	{
		texCoord_1 = ivec2(gl_WorkGroupID.x, id * 2);
		texCoord_2 = ivec2(gl_WorkGroupID.x, id * 2 + 1);

		texCoord_index_1 = texCoord_1.y;
		texCoord_index_2 = texCoord_2.y;

		texture_size_early_out = texture_size.y;
	}


	cache[id * 2] = texelFetch(sampler0, texCoord_1, 0).xyz;
	cache[id * 2 + 1] = texelFetch(sampler0, texCoord_2, 0).xyz;


	if(id * 2 > texture_size_early_out)
	{
		imageStore(sampler1, texCoord_1, vec4(0.0));
		imageStore(sampler1, texCoord_2, vec4(0.0));
		return;
	}

	barrier();
	memoryBarrierShared();

	float coc = texture(sampler2, v_TexCoord).r;

	coc = min(coc * max_blur, max_blur);
	int num_samples = int(ceil(coc));

	/*
	if(num_samples <= 0)
	{
		return scene;
	}
	*/
	
	float SIGMA = float(num_samples) / 9.7;
	float SIGMA_2 = SIGMA * SIGMA;

	vec3 guass_increment;
	guass_increment.x = 1.0 / (sqrt(MATH_2_PI) * SIGMA);
	guass_increment.y = exp(-0.5 / SIGMA_2);
	guass_increment.z = guass_increment.y * guass_increment.y;
	
	
	vec3 output_1 = cache[texCoord_index_1] * guass_increment.x;
	vec3 output_2 = cache[texCoord_index_2] * guass_increment.x;

	float increment_sum = guass_increment.x;
	guass_increment.xy *= guass_increment.yz;



	for (int i = 1; i < blur_amount; i++)
	{
		int index = i;

		output_1 += cache[texCoord_index_1 + index] * guass_increment.x;
		output_1 += cache[texCoord_index_1 - index] * guass_increment.x;

		output_2 += cache[texCoord_index_2 + index] * guass_increment.x;
		output_2 += cache[texCoord_index_2 - index] * guass_increment.x;

		increment_sum += 2.0 * guass_increment.x;
		guass_increment.xy *= guass_increment.yz;
	}

	output_1 /= increment_sum;
	output_2 /= increment_sum;

	imageStore(sampler1, texCoord_1, vec4(output_1, 1.0));
	imageStore(sampler1, texCoord_2, vec4(output_2, 1.0));
}
