




//------------------------------------------------------
// Specular Function
//------------------------------------------------------
// Based on https://github.com/stackgl/glsl-specular-ward
float wardSpecular(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, vec2 slope) 
{

	float NdotL = dot(surfaceNormal, lightDirection);
	float NdotR = dot(surfaceNormal, viewDirection);

	if(NdotL < 0.0 || NdotR < 0.0) 
	{
		return 0.0;
	}

	vec3 H = normalize(lightDirection + viewDirection);

	vec3 fiberParallel = normalize(cross(viewDirection,surfaceNormal));
	vec3 fiberPerpendicular = normalize(cross(fiberParallel, surfaceNormal));

	float NdotH = dot(surfaceNormal, H);
	float XdotH = dot(fiberParallel, H);
	float YdotH = dot(fiberPerpendicular, H);

	float coeff = sqrt(NdotL/NdotR) / (4.0 * MATH_PI * slope.x * slope.y); 
	float theta = (pow(XdotH/slope.x, 2.0) + pow(YdotH/slope.y, 2.0)) / (1.0 + NdotH);

	float F = pow(1.0 - dot(viewDirection,H), 0.3);

	return coeff * exp(-2.0 * theta);
}

// Based on https://github.com/stackgl/glsl-specular-beckmann
float beckmannDistribution(float x, float roughness) 
{
	float NdotH = max(x, 0.0001);
	float cos2Alpha = NdotH * NdotH;
	float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;
	float roughness2 = roughness * roughness;
	float denom = MATH_PI * roughness2 * cos2Alpha * cos2Alpha;
	return exp(tan2Alpha / roughness2) / denom;
}

// Based on https://github.com/stackgl/glsl-specular-cook-torrance
float cookTorranceSpecular(
	vec3 lightDirection,
	vec3 viewDirection,
	vec3 surfaceNormal,
	float roughness,
	float fresnel) 
{

	float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);
	float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);

	//Half angle vector
	vec3 H = normalize(lightDirection + viewDirection);

	//Geometric term
	float NdotH = max(dot(surfaceNormal, H), 0.0);
	float VdotH = max(dot(viewDirection, H), 0.000001);
	float LdotH = max(dot(lightDirection, H), 0.000001);
	float G1 = (2.0 * NdotH * VdotN) / VdotH;
	float G2 = (2.0 * NdotH * LdotN) / LdotH;
	float G = min(1.0, min(G1, G2));
  
	//Distribution term
	float D = beckmannDistribution(NdotH, roughness);

	//Fresnel term
	float F = max(pow(1.0 - VdotN, fresnel), 0.000001);

	//Multiply terms and done
	return  G * F * D / max(MATH_PI * VdotN, 0.000001);
}

//------------------------------------------------------
// TEXT
//------------------------------------------------------
void calcLighting(
	vec2 tex_coord, 
	vec3 world_position, vec3 world_normal, 
	vec3 cam_position,
	vec3 light_position, vec3 light_color, float light_intensity, float light_falloff,
	vec4 specular_properties,
	out vec3 L, out vec4 diffuse_out, out vec4 specular_out)
{
	
	//------------------------------------------------------
	// Lighting Vectors
	//------------------------------------------------------
	// Normal
	vec3 N = normalize(world_normal);
	// View Direction
	vec3 E = normalize(-cam_position - world_position);

	// Light to Object Vector
	vec3 light_to_object = (light_position - world_position);

	// Light to Object Distance Squared
	float light_distance_2 = dot(light_to_object, light_to_object);

	// Light to Object Distance
	float light_distance = sqrt(light_distance_2);

	// Light to Object Direction
	L = light_to_object / light_distance;

	//------------------------------------------------------
	// Attenuation
	//------------------------------------------------------
	float max_light_brightness = 9.0;
	float light_bright = (light_intensity / max_light_brightness);
	float light_falloff_2 = light_falloff * light_falloff;


	float attenuation = max(1.0 - light_distance_2 / light_falloff_2, 0.0);
	attenuation *= attenuation;
	attenuation *= light_bright;


	//------------------------------------------------------
	// Angle of Inclination
	//------------------------------------------------------
	float angle_of_inc = dot(L,N);
	float max_inc = max(angle_of_inc, 0.0);

	//------------------------------------------------------
	// Diffuse
	//------------------------------------------------------
	vec4 diffuse = vec4(light_color * max_inc, 1.0);


	//------------------------------------------------------
	// Specular
	//------------------------------------------------------
	float specular_shininess = specular_properties.a;
	vec3 specular_color = specular_properties.xyz;

	/*
	vec3 half_angle = normalize(L + E);

	float angleNormalHalf = acos(dot(half_angle,N));
	float exponent = angleNormalHalf * (specular_shininess * 1.0);
	exponent = -(exponent * exponent);
	float gaussianTerm = exp(exponent);

	//gaussianTerm = max_inc != 0.0 ? gaussianTerm : 0.0;
	*/

	vec2 slope = vec2(specular_shininess);
	float gaussianTerm = wardSpecular(L, E, N, slope);

	//gaussianTerm = cookTorranceSpecular(L, E, N, specular_shininess, 0.9);

	vec4 specular = vec4(
		light_color *
		(gaussianTerm * max_inc) *
		specular_color, 1.0
	);


	//------------------------------------------------------
	// Add it all together
	//------------------------------------------------------
	diffuse_out = attenuation * diffuse;

	specular_out = attenuation * specular;


	vec3 spec;
	vec3 diff;

	//diffuse_out = vec4(attenuation * diff,1.0);
	//specular_out = vec4(light_color * spec * attenuation * specular_color, 1.0);
}